#ifndef _Math_Vector3_H
#define _Math_Vector3_H

#include <Math/Vector.h>
#include <Math/Vector2.h>


namespace Math
{

	///////////////////////////////////////////////////////////////////////////////////
	/// \brief Three dimensional vector
	/// 	   
	/// \param Float : scalar type	   
	/// 
	/// \author F. Lamarche, University of Rennes 1.
	///////////////////////////////////////////////////////////////////////////////////
	template <class Float>
	class Vector3 : public Vector<Float, 3>
	{
	public:
		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Default constructor
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		Vector3() : Vector<Float, 3>()
		{}


		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Constructor with (x,y,z) coordinates
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		Vector3(Float const & x, Float const & y, Float const & z)
		{
			(*this)[0]=x ;
			(*this)[1]=y ;
			(*this)[2]=z ;
		}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Copy constructor
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		Vector3(Vector<Float,3> const & v) : Vector<Float,3>(v)
		{}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Copy constructor
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		Vector3(Vector3<Float> const & v) : Vector<Float,3>(v)
		{}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Generic copy constructor
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		template <class Float2>
		Vector3(Vector<Float2, 3> const & v)
			: Vector<Float,3>(v)
		{}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Cross product
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		Vector3<Float> operator^(Vector3<Float> const & v) const
		{
			Vector3<Float> result ;
			result[0] = (*this)[1]*v[2]-(*this)[2]*v[1] ;
			result[1] = (*this)[2]*v[0]-(*this)[0]*v[2] ;
			result[2] = (*this)[0]*v[1]-(*this)[1]*v[0] ;
			return result ;
		}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Assignation operator
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////			
		Vector3<Float> & operator= (Vector3<Float> const & v) 
		{	
			for(int cpt=0 ; cpt<3 ; cpt++)
			{
				(*this)[cpt]=v[cpt] ;
			}
			return (*this) ; 
		}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Returns X coordinate
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		const Float & x() const
		{
			return (*this)[0] ;
		}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Returns Y coordinate
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		const Float & y() const
		{
			return (*this)[1] ;
		}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Returns Z coordinate
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		const Float & z() const
		{
			return (*this)[2] ;
		}

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Projection along the Z axis
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		Vector2<Float> projectZ() const
		{ return Math::Vector2<Float>(x(), y()) ; }

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Projection along the Y axis
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		Vector2<Float> projectY() const
		{ return Math::Vector2<Float>(x(), z()) ; }

		///////////////////////////////////////////////////////////////////////////////////
		/// \brief Projection along the X axis
		/// 
		/// \author F. Lamarche, University of Rennes 1.
		///////////////////////////////////////////////////////////////////////////////////
		Vector2<Float> projectX() const
		{ return Math::Vector2<Float>(y(), z()) ; }

		static Float det(Vector3 const & v1, Vector3 const & v2, Vector3 const & v3)
		{
			return v1[0]*Vector2<Float>::det(v2.projectX(), v3.projectX())-v2[0]*Vector2<Float>::det(v1.projectX(), v3.projectX())+v3[0]*Vector2<Float>::det(v1.projectX(), v2.projectX()) ;
		}
	} ;
}


#endif
